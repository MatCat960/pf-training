import numpy as np
from scipy.spatial import Voronoi, voronoi_plot_2d
import matplotlib.pyplot as plt
import random
from shapely import Polygon, Point, intersection
from tqdm import tqdm
from pathlib import Path
import pyvoro
from mpl_toolkits.mplot3d.art3d import Poly3DCollection
from scipy.spatial import ConvexHull, Delaunay

epochs = 1
ROBOTS_NUM = 12
ROBOTS_MAX = 20
AREA_W = 40.0
vmax = 1.5
NUM_STEPS = 150

def in_poly_hull_single(poly, point):
    hull = ConvexHull(poly)
    new_hull = ConvexHull(np.concatenate((poly, [point])))
    return np.array_equal(new_hull.vertices, hull.vertices)

points = -0.5*AREA_W + AREA_W * np.random.rand(ROBOTS_NUM, 3)


for ep in range(NUM_STEPS):
    voronoi = pyvoro.compute_voronoi(points,[[-0.5*AREA_W, 0.5*AREA_W],[-0.5*AREA_W, 0.5*AREA_W],[-0.5*AREA_W, 0.5*AREA_W]],2)
    # print(voronoi)

    # fig = plt.figure()
    # ax = fig.add_subplot(111, projection='3d')

    # for each Voronoi cell, plot all the faces of the corresponding polygon
    v = 0
    conv = True
    for vnoicell in voronoi:
        faces = []
        # the vertices are the corner points of the Voronoi cell
        vertices = np.array(vnoicell['vertices'])
        p = vnoicell['original']
        
        # get min and max for each axis
        x_min = np.min(vertices[:,0])
        x_max = np.max(vertices[:,0])
        y_min = np.min(vertices[:,1])
        y_max = np.max(vertices[:,1])
        z_min = np.min(vertices[:,2])
        z_max = np.max(vertices[:,2])


        # Calculate centroid of the 3D voronoi cell
        area = 0.0
        Cx = 0.0; Cy = 0.0; Cz = 0.0
        dV = 0.1 ** 3

        for i in np.arange(x_min, x_max, (x_max-x_min)/10):
            for j in np.arange(y_min, y_max, (y_max-y_min)/10):
                for k in np.arange(z_min, z_max, (z_max-z_min)/10):
                    if Delaunay(vertices).find_simplex(np.array([i,j,k])) >= 0:
                        area += dV
                        Cx += i * dV
                        Cy += j * dV
                        Cz += k * dV
        
        Cx = Cx / area
        Cy = Cy / area
        Cz = Cz / area

        centr = np.array([Cx, Cy, Cz]).transpose()
        # print(f"Robot: {robot}")
        # print(f"Centroid: {centr}")
        robot = vnoicell['original']
        dist = np.linalg.norm(robot-centr)
        if dist > 0.1:
            conv = False

        vel = 0.8 * (centr - robot)
        vel[0] = max(-vmax, min(vmax, vel[0]))
        vel[1] = max(-vmax, min(vmax, vel[1]))
        vel[2] = max(-vmax, min(vmax, vel[2]))
        points[v, :] = robot + vel


        v += 1

    if conv:
        print(f"Converged in {ep} iterations.")
        break

    
fig = plt.figure()
ax = fig.add_subplot(111, projection='3d')
voronoi = pyvoro.compute_voronoi(points,[[-0.5*AREA_W, 0.5*AREA_W],[-0.5*AREA_W, 0.5*AREA_W],[-0.5*AREA_W, 0.5*AREA_W]],2)
for vnoicell in voronoi:
    faces = []
    # the vertices are the corner points of the Voronoi cell
    vertices = np.array(vnoicell['vertices'])
    p = vnoicell['original']


    # cycle through all faces of the polygon
    for face in vnoicell['faces']:
        faces.append(vertices[np.array(face['vertices'])])
        
    # join the faces into a 3D polygon
    polygon = Poly3DCollection(faces, alpha=0.5, 
                               facecolors=np.random.uniform(0,1,3),
                               linewidths=0.5,edgecolors='black')
    ax.add_collection3d(polygon)
    
plt.show()

fig = plt.figure()
ax = fig.add_subplot(111, projection='3d')
for pt in points:
    ax.scatter(pt[0], pt[1], pt[2])

plt.show()



